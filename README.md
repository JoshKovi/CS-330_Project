# CS-330_Project
This is a demonstration of a 3D scene in OpenGL for x86. This scene has lighting, reflections, camera movement and light changing/movement.


  
  I approach designing software in a very systematic way. Typically, once I have an idea of what I want to do I build a messy working prototype function 
or method(more often when the work is complicated) to work out the details. Once I have an idea of how I want to implement the code, and what works best
I start to optimize and clean up my code, removing unused and unneeded portions. This allows me to have an overall understanding of exactly what I need
without worrying about code clarity at first. Typically, if this work exceeds what I can do in one sitting, I will clean up my code and comment it so
that if I do not see it again for a day I am not overwhelmed with commented sections or unclear code. This project has helped me specifically in marking
my current changes to the program from its last functional state. I typically also centralize my code in progress now to make it less difficult for me to
identify what has been changed if the code suddenly stops working. This process, along with working my functionality out before making the code clean 
and optimized has ended up saving me a lot of time as it only takes a couple minutes to extract the working code, and a few more to optimize it, but trying
to write exceptionally clean, commented and optimized code the first time often ends up wasting a lot of time as inevitably something will not work and the
clean commented code will need to be scraped or partially rewritten.
  The Computer Science coursework thusfar has helped me take my hobby and turn it into a viable career path. While I could learn programming and design philosophy 
on my own, the structured nature of college courses along with deadlines and expectations helps me focus and get my work done in a more efficient manner. Whereas
when I am working on my own projects and following tutorials I tend not to pace at all. Sometimes I will code/learn for 30 hours straight just to not touch the code
again for 2 weeks and sometimes I will only spend an hour or so a day learning new things. With college work I have learned to more appropriately pace myself as to 
avoid burning out or slacking off which has been a large help on my side projects as well (when coursework/work allows). Computational graphics like the ones used in
this course really put into perspective the math involved with some aspects of software development. I was lucky that I remembered a fair bit of my previous math classes 
as this course may have been even more challenging than it was if I did not. 
